# Autopilot Development (APD)

> **人間は意思決定だけ、AIが自律で完走する**

Autopilot Development（APD）は、AIエージェントが自律的にソフトウェアを開発し、人間はCheckpoint（確認ポイント）でのみ意思決定を注入する開発フレームワークである。自動運転のメタファーに基づき、人間が目的地とルートを決め、AIがAutopilotで走る。

---

## 設計原則

### AIに任せられる部分を限りなく増やす

AIフェーズの途中では人間の介入をゼロにする。モック・ユーザーストーリー・テストを含め、人間が意図した通りの機能実装がAIで完走する。人間の介入が必要で実装が止まるということを避ける。

### 「人間の時間」と「AIの時間」の分離

- **Phase 0〜1（Design〜Spec）= 人間の時間**: 人間とAIが対話し、意思決定を注入する
- **Phase 2〜3（Contract〜Execute）= AIの時間**: AI自律実行。Human Checkpointは軽量（サマリーベース承認）

### Human Checkpoint / AI Checkpoint の2層構造

```
AI作業 → AI Checkpoint（エージェント間レビュー）→ Human Checkpoint（最終承認）
```

- **Human Checkpoint**: フェーズ境界に置く。人間が意思決定を注入するポイント。通過/却下の関所ではなく、方向性を確認して必要なら調整する確認ポイント
- **AI Checkpoint**: Human Checkpointの手前に置く。エージェント間のクロスチェック。人間に上がる前にAI同士で品質を担保する
- Human Checkpointに上がる時点で、AIレビューサマリー + 要判断項目リストが付いており、人間は「全量レビュー」ではなく「例外レビュー」を行う

### AI Checkpointのパターン

| パターン | 役割 | 強み |
|---|---|---|
| ピアレビュー（コンテキスト横断） | 別コンテキスト担当エージェントがレビュー | 仕様の曖昧さ・コンテキスト間整合性の発見 |
| 専任レビューエージェント | 実装に関与しないレビュー専任 | Exit Criteriaの機械的チェック |
| 組み合わせ | ピア（ドメイン観点）+ 専任（形式観点） | 両方の長所を活かす |

### イミュータブルなドキュメント管理

- ドキュメントは上書きしない。修正が必要な場合はAmendment（差分ドキュメント）を発行する
- 全サイクルの軌跡が時系列で参照可能
- AIの作業記録: Gitコミットログ + AI Checkpointレビューサマリー（自動生成）
- 人間の判断記録: Decision Record（第一級成果物）

### 判断のエスカレーション

フレームワーク全体を通じて、以下の判断フローに従う。

1. CLAUDE.mdに明記されている → それに従う
2. CLAUDE.mdに書かれていない → リーダーエージェントに判断を仰ぐ
3. リーダーエージェントが判断できない → Human Checkpointにエスカレーション

判断に迷ったら自己判断せずリーダーに聞く。聞きすぎるほうが暴走するより安全。頻出の判断はCLAUDE.mdに昇格させて自律範囲を広げていく。

---

## フェーズ構成

```
Phase 0: Design ── 人間 + AI 対話（並列化しない）
  成果物: プロジェクトデザイン文書（北極星）
  性質: 対話的・創造的
  ─────────────── Human Checkpoint 0 ───────────────

Phase 1: Spec ── AIドラフト + 人間フィードバック（並列化しない）
  成果物: スペック集 + Decision Records
  性質: AIが叩き台を出し、人間が方向修正
  ─────────────── Human Checkpoint 1 ───────────────
  ここから先、人間は基本介入しない

Phase 2: Contract ── AI自律
  成果物: プロジェクト契約
  AI Checkpoint: Specエージェントが検証
  ─────────────── Human Checkpoint 2（軽量）──────────
  サマリーベース承認。問題なければ数分で通過。

Phase 3: Execute ── AI自律・並列実行
  成果物: 実装 + テスト全パス
  AI Checkpoint: ピアレビュー + 専任レビュー
  ─────────────── Human Checkpoint 3（軽量）──────────
  モック一致確認 + 例外レビューのみ。
```

---

## Phase 0: Design

### 目的

プロダクトの存在理由を定義する。「北極星」であり、毎回作り直すものではない。

### Design文書の構造

Amazon PR/FAQ を参考にした構成:

- **Who**: 誰のためのプロダクトか
- **Why**: なぜ今これを作るのか
- **What**: 何ができるようになるか（ユーザー視点）
- **What Not**: 何をやらないか（スコープ外の明示）← 特に重要
- **FAQ**: 想定される疑問と回答
- **Success Criteria**: 何をもって成功とするか

### 進め方

人間とAIが対話的にDesign文書を作成する。このフェーズは創造的な作業であり、並列化しない。

### Design文書に戻るとき

枠を超える変更が来たときだけDesignに戻る。通常の機能追加やバグ修正ではDesignには触れない。

---

## Phase 1: Spec

### 目的

Design文書に基づき、実装可能な詳細仕様を定義する。

### 進め方

1. 人間がサイクルのトリガーを与える（機能概要、バグ報告等）
2. AIがDesign文書 + 既存Specを読み、Specのドラフトを一気に生成する
3. AIはExit Criteriaの充足状況サマリーと、自信のない箇所（「ここは推論で埋めました、確認してください」）を提示する
4. 人間がドラフトを見て「ここが違う」「これを追加」とフィードバック
5. 数往復で収束
6. Human Checkpoint 1で承認

人間はドラフト全体を精読する必要はなく、AIが提示したサマリーと確認依頼箇所だけ見ればよい。

### Exit Criteria

- 全機能にスペックが存在する
- 各スペックに以下が含まれる:
  - ユーザーストーリー（誰が・何を・なぜ）
  - 受け入れ条件
  - モック or UI記述（該当する場合）
  - コンテキスト境界の定義
- コンテキスト間のデータフローが特定されている
- Decision Recordが作成されている（判断が発生した場合）

### スペックフォーマット

フレームワークとしてフォーマットは固定しない。Exit Criteriaを満たせばよい。ボイラープレートのCLAUDE.mdにデフォルトのフォーマット指定を含め、プロジェクトごとにカスタマイズする。

---

## Phase 2: Contract

### 目的

Specに基づき、AIが自律的に実装するための契約（技術的な実装仕様）を定義する。

### 進め方

AI自律で生成する。Specエージェントが検証するAI Checkpointを経て、Human Checkpoint 2（軽量）で承認。

### 必須項目

- Specの全要件に対する技術的実現方法
- コンテキスト間の境界情報（インターフェース定義）
- テスト戦略（何をどのレベルでテストするか）

コンテキスト間インターフェース定義のフォーマットはフレームワークでは規定しない。プロジェクトの技術スタックに応じてリーダーエージェントが判断する。

---

## Phase 3: Execute

### 目的

Contractに基づき、AIが自律的に実装とテストを行う。

### 並列実行の原則

1. コンテキスト間の境界はContractに定義されていること
2. 並列実行する各エージェントは、他コンテキストの実装に直接依存せずに開発・テストできること
3. 全エージェントの実装完了後、結合検証を行うこと

並列化の単位、独立性の確保方法、結合検証の方法はリーダーエージェントが決定する。

### AI Checkpoint

リーダーエージェントはテストの品質を評価し、Specの受け入れ条件との対応が不十分な場合は差し戻す。

- テストが受け入れ条件をカバーしているか
- テストが実質的か（形だけのテスト、何も検証していないアサーションを検出）
- エラーケース・境界条件のテストがあるか

### Exit Criteria

- Contractに定義された全要件が実装されている
- テストが全パスしている
- AI Checkpointレビューが完了している

### テスト戦略

フレームワークとしてテスト戦略は固定しない。「テストが全パスしていること」のみ必須。何をどうテストするかはContractでリーダーエージェントが定めるか、CLAUDE.mdにプロジェクト固有の方針として記載する。

---

## サイクル型統一フロー

すべての変更を「サイクル」として統一し、トリガーの種類によって通過するフェーズが決まる。修正は新しいサイクルで行う（出戻りではなく前進）。

```
サイクルのトリガー（人間が起点を与える）
  │
  ├─ "新プロダクト / 大きな方向転換"
  │    → Design → Spec → Contract → Execute（フルサイクル）
  │
  ├─ "新機能追加"
  │    → Spec（既存Design参照）→ Contract差分 → Execute
  │
  ├─ "バグ修正 / 小さな改善"
  │    → Spec Amendment → Execute（Contract変更なし）
  │
  └─ "技術的変更（リファクタ・依存更新）"
       → Contract Amendment → Execute（Spec変更なし）
```

### サイクル定義の例

```yaml
# cycle/C-003.md
cycle_id: C-003
trigger: "feature_addition"
title: "注文の一括出荷機能"
design_ref: "docs/apd/design/product-design.md"

spec_changes:
  - type: "new_spec"
    id: OM-003
    context: order-management
  - type: "amendment"
    target: OM-001
    amendment_id: A-005

decisions:
  - D-012: "一括選択の上限は100件。パフォーマンス観点。"
  - D-013: "一括出荷時のエラーは個別スキップ方式。UX観点。"

contract_changes:
  - amendment_id: C-003
    change: "バッチAPI追加"
```

### バグのトリアージ（AI Checkpoint委譲）

バグ報告・テスト失敗が来たとき、AIがまず原因を判定する:

- **Spec起因**（仕様漏れ・仕様の曖昧さ）→ 人間にエスカレーション。Spec Amendmentサイクルへ
- **Execute起因**（実装がSpecと合っていない）→ AI自律で修正。人間に上げない

---

## Decision Record

人間の意思決定を記録する軽量フォーマット。「なぜこの仕様になったか」「なぜこの案を却下したか」を残す。

```yaml
# docs/apd/decisions/D-001.md
id: D-001
phase: spec
date: 2025-07-10
context: "注文ダッシュボードのフィルタ方式"
options:
  - "A: サーバーサイドフィルタ（AIが提案）"
  - "B: クライアントサイドフィルタ（AIが提案）"
decision: "A"
reason: "データ量が10万件超になる想定。人間判断。"
impact: [OM-001]
```

- AIが選択肢を生成し、人間が選んだ結果と理由だけ記録する
- 理由は一言でよい
- 修正サイクルでは新しいDecision Recordが追加される（上書きしない）

---

## AI Checkpointエスカレーションポリシー

デフォルト: AI Checkpointで完結。以下に該当する場合のみHuman Checkpointにエスカレーションする。

### Human Checkpoint必須

- 新しいビジネスルール（既存Specにないドメインロジック）
- 外部システムとのインターフェース変更
- セキュリティ・認証に関わる変更
- データモデルの破壊的変更
- パフォーマンス要件の緩和

### AI Checkpoint完結

- UI調整（Design文書の範囲内）
- 既存ビジネスルール内のバリエーション追加
- リファクタリング（振る舞い変更なし）
- テストカバレッジ補強
- ドキュメント文言修正

このポリシーはプロジェクトのCLAUDE.mdに記載する。プロジェクト固有の追加・変更がある場合はCLAUDE.mdを編集し、変更理由はDecision Recordに残す。

---

## リーダーエージェント

### 位置づけ

プロジェクト全体のコンテキストを持ち、フレームワークのルールとプロジェクトのDesign/Spec/Contractを踏まえて判断を下すエージェント。Phase 2〜3において、各作業エージェントの上位に立つ。

### 責務

- フレームワークに規定がない判断を行う
- 自身で判断できない場合はHuman Checkpointにエスカレーションする
- Phase 3の実行計画を策定する（並列化の単位、境界の表現方法、結合検証の方法等）
- テスト品質を評価し、Specの受け入れ条件との対応が不十分な場合は差し戻す

---

## ドキュメントツリー

```
project/
├── .claude/
│   └── rules/apd/                          ← APDフレームワーク方針（自動ロード）
├── docs/apd/
│   ├── design/
│   │   └── product-design.md               ← 北極星（滅多に変わらない）
│   ├── specs/
│   │   ├── order-management.v1.md          ← イミュータブル
│   │   ├── order-management.v1.A-005.md    ← Amendment
│   │   ├── _cross-context-scenarios.md
│   │   └── ...
│   ├── contract/
│   │   ├── project-contract.v1.md          ← イミュータブル
│   │   ├── project-contract.v1.C-003.md    ← Amendment
│   │   └── ...
│   ├── decisions/
│   │   ├── D-001.md
│   │   ├── D-002.md
│   │   └── ...                             ← 時系列で積み上がる
│   └── cycles/
│       ├── C-001.md                        ← 初回フルサイクル
│       ├── C-002.md                        ← 機能追加サイクル
│       └── ...
└── src/ + tests/                           ← Git管理
```

---

## 設定ファイルの構成

APDフレームワークの設定は、Claude Codeの `.claude/rules/` 機能を活用して2層に分離する。

### フレームワーク方針（`.claude/rules/apd/`）

`.claude/rules/` に置かれた `.md` ファイルはClaude Codeが自動的にプロジェクトメモリとして読み込む。フレームワーク方針をここに格納することで、`CLAUDE.md` を圧迫せず、既存プロジェクトへの導入も容易になる。

```
.claude/rules/apd/
├── 00-principles.md   ← 基本原則・エスカレーションフロー
├── 01-phases.md       ← フェーズ定義・Checkpoint原則・エスカレーションポリシー
├── 02-cycle-flow.md   ← サイクル型統一フロー・バグトリアージ
├── 03-documents.md    ← ドキュメント管理・ツリー・スペックフォーマット
└── 04-testing.md      ← テスト方針
```

### プロジェクト固有設定（`CLAUDE.md`）

プロジェクトごとにカスタマイズする設定は従来通り `CLAUDE.md` に記述する。既存の `CLAUDE.md` がある場合はそこに追記する形で導入できる。

- エスカレーションポリシーの追加・変更
- スペックフォーマットのカスタマイズ
- テスト戦略の詳細
- 技術スタック固有のルール
- コーディング規約

CLAUDE.mdの変更はGitコミットログで追跡する。ポリシー変更の「なぜ」はDecision Recordに残す。
